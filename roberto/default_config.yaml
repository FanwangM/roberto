project:
  name: null
  packages: [
  # Repeat as many as you like. The order determines the order in which they
  # are linted, tested, built, etc.
  # - conda_name: 'name of the conda package'
  #   tools: [] # list, any of the tools defined below
  #   name: '' # python or cpp name, defaults to project.name
  #   path: # root of the package relative to the project root defaults to '.'
  ]

# Custom configuration below this line should be rarely needed.

run:
  echo: true
conda:
  download_path: '${HOME}/Downloads/miniconda.sh'
  linux_url: 'https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh'
  osx_url: 'https://repo.continuum.io/miniconda/Miniconda3-latest-MacOSX-x86_64.sh'
  base_path: '${HOME}/miniconda3'
  # The pinning config must be a string of words separated by whitespace,
  # alternating package and version number. These packages will be pinned at
  # the given version in conda. Don't use wildcards.
  pinning: 'python 3.7'
  channels: [conda-forge]  # you practically always need to include conda-forge.
  # The following are set automatically...
  env_name: null  # The name of the conda development environment.
  env_path: null  # The path of the conda development environment.
deploy: false
upload_coverage: false
git:
  # Name of the branch being merged into, may be same as git.branch, if not a PR.
  merge_branch: master
  # The following are set automatically...
  branch: null  # name of the current branch
  describe: null  # output of git describe --tags
  tag: null  # the most recent tag
  tag_version: null  # version name derived from git describe, i.e. major.minor.patch{.post}
  tag_soversion: null  # the so-version, i.e. major.minor
  tag_version_major: null
  tag_version_minor: null
  tag_version_patch: null
  tag_version_suffix: null
  tag_stable: false  # is the current build a stable or main release?
  tag_test: false  # is the current build a test or beta release?
  tag_dev: false  # is the current build a development or alpha release?
  tag_release: false  # is the current build a release

tools:
  write-py-version:
    task: write-version
    template: |
      """Do not edit this file because it will be overwritten before packaging.

      The output of git describe was: {config.git.describe}
      """
      __version__ = '{config.git.tag_version}'
    destination: '{package.name}/version.py'

  write-cmake-version:
    task: write-version
    template: |
      # This file is automatically generated. Changes will be overwritten before packaging.
      set(GIT_DESCRIBE "{config.git.describe}")
      set(GIT_TAG_VERSION "{config.git.tag_version}")
      set(GIT_TAG_SOVERSION "{config.git.tag_soversion}")
      set(GIT_TAG_VERSION_MAJOR "{config.git.tag_version_major}")
      set(GIT_TAG_VERSION_MINOR "{config.git.tag_version_minor}")
      set(GIT_TAG_VERSION_PATCH "{config.git.tag_version_patch}")
    destination: 'CMakeListsVersion.txt.in'

  cardboardlint-static:
    task: lint-static
    pip_requirements:
      - git+https://github.com/theochem/cardboardlint.git@master#egg=cardboardlint
    conda_requirements:
      - pycodestyle
      - pydocstyle
      - cppcheck
      - cpplint
      - yamllint
    commands_master:
      - cardboardlinter -f static
    commands_feature:
      - 'cardboardlinter -r {config.git.merge_branch} -f static'

  cardboardlint-dynamic:
    task: lint-dynamic
    pip_requirements:
      - git+https://github.com/theochem/cardboardlint.git@master#egg=cardboardlint
    conda_requirements:
      - pylint
      - flake8
    commands_master:
      - cardboardlinter -f dynamic
    commands_feature:
      - 'cardboardlinter -r {config.git.merge_branch} -f dynamic'

  build-py-inplace:
    task: build-inplace
    paths:
      PYTHONPATH: '{package.path}/{package.name}'
    commands:
      - >-
        python setup.py build_ext -i -L $LD_LIBRARY_PATH
        -I $CPATH --define CYTHON_TRACE_NOGIL

  build-cmake-inplace:
    task: build-inplace
    paths:
      CPATH: '{package.path}'
      LD_LIBRARY_PATH: '{package.path}/build/{package.name}'
    commands:
      - mkdir -p build
      - cd build; cmake .. -DCMAKE_BUILD_TYPE=debug
      - cd build; make

  pytest:
    task: test-inplace
    conda_requirements:
      - pytest
      - pytest-cov
    commands:
      - >-
        pytest {package.name} -v --cov={package.name} --cov-report xml
        --cov-report term-missing --cov-branch --color=yes

  nose:
    task: test-inplace
    conda_requirements:
      - nose
      - coverage
    commands:
      - rm -f .coverage
      - >-
        nosetests {package.name} -v --detailed-errors --with-coverage
        --cover-package={package.name} --cover-tests --cover-inclusive
        --cover-branches
      - coverage xml -i

  maketest:
    task: test-inplace
    pip_requirements:
      - gcovr
    commands:
      - cd build; find | grep '\\.gcda$' | xargs rm -vf
      - cd build; make test
      - >-
        cd {package.name}; gcovr -r . --gcov-executable ${{HOST}}-gcov
        --object-directory ../build/{package.name}/CMakeFiles/{package.name}.dir

  build-py-source:
    task: build-packages
    commands:
      - python setup.py sdist

  build-cmake-source:
    task: build-packages
    commands:
      - mkdir -p dist
      - cd dist; cmake .. -DCMAKE_BUILD_TYPE=release
      - cd dist; make sdist

  build-conda:
    task: build-packages
    conda_requirements:
      - conda-build
      - conda-verify
    commands:
      # CONDA_BUILD_PATH must be set because otherwise local dependencies
      # cannot be found when working in any other environment than base.
      # See https://github.com/conda/conda-build/issues/2592
      - >-
        CONDA_BUILD_PATH={config.conda.build_path}
        PROJECT_VERSION={config.git.tag_version}
        conda build tools/conda.recipe --override-channel

  deploy-pypi:
    task: deploy
    conda_requirements:
      - twine
    deploy-vars:
      - TWINE_USERNAME
      - TWINE_PASSWORD
    asset_pattern: '{package.path}/dist/{package.name}-{config.git.tag_version}.*'
    deploy-labels:
      - main
    commands:
      - twine upload {assets}

  deploy-github:
    task: deploy
    conda_requirements:
      - hub
    deploy-vars:
      - GITHUB_TOKEN
    asset_pattern: '{package.path}/dist/{package.name}-{config.git.tag_version}.*'
    deploy-labels:
      - main
    commands:
      - >-
        hub release create {hub_assets}
        -m "Automatic release of version {config.git.tag_version}"
        {config.git.tag_version}

  deploy-conda:
    task: deploy
    conda_requirements:
      - anaconda-client
    deploy-vars:
      - ANACONDA_API_TOKEN
    asset_pattern: '{config.conda.build_path}/*/{package.name}-{config.git.tag_version}-*.*'
    deploy-labels:
      - main
      - test
      - dev
    commands:
      - 'anaconda -v upload --force -l {deploy-label} {assets}'
