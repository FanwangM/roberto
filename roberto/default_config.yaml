project:
  name: null
  packages: [
  # Repeat as many as you like. The order determines the order in which they
  # are linted, tested, built, etc.
  # - conda_name: 'name of the conda package'
  #   tools: [] # list, any of the tools defined below
  #   name: '' # python or cpp name, defaults to project.name
  #   path: # root of the package relative to the project root defaults to '.'
  ]

# Custom configuration below this line should be rarely needed.

run:
  echo: true
conda:
  download_path: '${HOME}/Downloads/miniconda.sh'
  linux_url: 'https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh'
  osx_url: 'https://repo.continuum.io/miniconda/Miniconda3-latest-MacOSX-x86_64.sh'
  base_path: '${HOME}/miniconda3'
  # The pinning config must be a string of words separated by whitespace,
  # alternating package and version number. These packages will be pinned at
  # the given version in conda. Don't use wildcards.
  pinning: 'python 3.7'
  channels: [conda-forge]  # you practically always need to include conda-forge.
  # The following are set automatically...
  env_name: null  # The name of the conda development environment.
  env_path: null  # The path of the conda development environment.
deploy_noarch: false  # Set to true for deployment of architecture-independent files.
deploy_binary: false  # Set to true for deployment of architecture-dependent files.
upload_coverage: false
git:
  # Name of the branch being merged into, may be same as git.branch, if not a PR.
  merge_branch: master
  # The following are set automatically...
  branch: null  # name of the current branch
  describe: null  # output of git describe --tags
  tag: null  # the most recent tag
  tag_version: null  # version name derived from git describe, i.e. major.minor.patch{.post}
  tag_soversion: null  # the so-version, i.e. major.minor
  tag_version_major: null
  tag_version_minor: null
  tag_version_patch: null
  tag_version_suffix: null
  tag_stable: false  # is the current build a stable or main release?
  tag_test: false  # is the current build a test or beta release?
  tag_dev: false  # is the current build a development or alpha release?
  tag_release: false  # is the current build a release

tools:
  write-py-version:
    # The task write-version writes version information to files in the source
    # tree.
    task: write-version
    # A template for the file to be written, usually short.
    # You can use python string formatting to insert fields
    # from the configuration. When Roberto starts, it derives
    # the version from the git tag and stores it in the
    # configuration. It can be inserted as {config.git.tag_version}.
    template: |
      """Do not edit this file because it will be overwritten before packaging.

      The output of git describe was: {config.git.describe}
      """
      __version__ = '{config.git.tag_version}'
    # The file to be written. Existing files are overwritten.
    destination: '{package.name}/version.py'

  write-cmake-version:
    task: write-version
    template: |
      # This file is automatically generated. Changes will be overwritten before packaging.
      set(GIT_DESCRIBE "{config.git.describe}")
      set(GIT_TAG_VERSION "{config.git.tag_version}")
      set(GIT_TAG_SOVERSION "{config.git.tag_soversion}")
      set(GIT_TAG_VERSION_MAJOR "{config.git.tag_version_major}")
      set(GIT_TAG_VERSION_MINOR "{config.git.tag_version_minor}")
      set(GIT_TAG_VERSION_PATCH "{config.git.tag_version_patch}")
    destination: 'CMakeListsVersion.txt.in'

  cardboardlint-static:
    # The task lint-static performs linting that does not require interpretation
    # or compilation of the source code.
    task: lint-static
    pip_requirements:
      - git+https://github.com/theochem/cardboardlint.git@master#egg=cardboardlint
    conda_requirements:
      - pycodestyle
      - pydocstyle
      - cppcheck
      - cpplint
      - yamllint
      - flake8
    # Commands to be executed when working in the merge_branch, usually
    # this is the master branch.
    commands_master:
      - cardboardlinter -f static
    # Commdands to be executed when working in a feature banch, which is to
    # be merged into the merge_branch. This makes it possible to filter out
    # linting messages that are unrelated to the changes in the feature branch.
    commands_feature:
      - 'cardboardlinter -r {config.git.merge_branch} -f static'

  build-py-inplace:
    # The task build-inplace builds the source code inside the repository and
    # it sets environment variables to use this in-place build. It also generates
    # an `activate-*.sh` script that can be sourced to use the in-place build
    # after Roberto has completed. The build should be configured with debug
    # and coverage settings enabled.
    task: build-inplace
    # Additions to PATH variables needed to use the in-place build.
    paths:
      PYTHONPATH: '{package.path}/{package.name}'
    # Bash commands to build in-place.
    commands:
      - >-
        python setup.py build_ext -i -L $LD_LIBRARY_PATH
        -I $CPATH --define CYTHON_TRACE_NOGIL

  build-cmake-inplace:
    task: build-inplace
    paths:
      CPATH: '{package.path}'
      LD_LIBRARY_PATH: '{package.path}/build/{package.name}'
    commands:
      - mkdir -p build
      - cd build; cmake .. -DCMAKE_BUILD_TYPE=debug
      - cd build; make

  pytest:
    # The task test-inplace performs unit and other tests after the in-place
    # build.
    task: test-inplace
    conda_requirements:
      - pytest
      - pytest-cov
    # Bash commands to perform the tests. Environment variables defined in the
    # in-place build will still be set.
    commands:
      - >-
        pytest {package.name} -v --cov={package.name}
        --cov-report xml:coverage_pytest.xml
        --cov-report term-missing
        --cov-branch --color=yes

  nose:
    task: test-inplace
    conda_requirements:
      - nose
      - coverage
    commands:
      - rm -f .coverage
      - >-
        nosetests {package.name} -v --detailed-errors --with-coverage
        --cover-package={package.name} --cover-tests --cover-inclusive
        --cover-branches
      - coverage xml -i -o coverage_nose.xml

  maketest:
    task: test-inplace
    pip_requirements:
      - gcovr
    commands:
      - cd build; find | grep '\\.gcda$' | xargs rm -vf
      - cd build; make test
      - >-
        cd {package.name}; gcovr -r . --gcov-executable ${{HOST}}-gcov
        --object-directory ../build/{package.name}/CMakeFiles/{package.name}.dir

  cardboardlint-dynamic:
    # The task lint-static performs linting that does require interpretation
    # or compilation of the source code.
    task: lint-dynamic
    pip_requirements:
      - git+https://github.com/theochem/cardboardlint.git@master#egg=cardboardlint
    conda_requirements:
      - pylint
    # Commands to be executed when working in the merge_branch, usually
    # this is the master branch.
    commands_master:
      - cardboardlinter -f dynamic
    # Commdands to be executed when working in a feature banch, which is to
    # be merged into the merge_branch. This makes it possible to filter out
    # linting messages that are unrelated to the changes in the feature branch.
    commands_feature:
      - 'cardboardlinter -r {config.git.merge_branch} -f dynamic'

  build-sphinx-doc:
    # The task build-docs compiles the (online) documentation.
    task: build-docs
    conda_requirements:
      - sphinx
    pip_requirements:
      - sphinxcontrib-napoleon
      - sphinx-autodoc-typehints
      - sphinx-rtd-theme
    # Bash commands to build the documentation
    commands:
      - cd doc; make html

  upload-docs-gh:
    # The task upload-docs-git pushes the previously built documentation to a
    # git branch of choice.
    task: upload-docs-git
    # The root of the documentation website.
    docroot: '{package.path}/doc/_build/html'
    # The branch to push to. Changes will be amended and force-pushed.
    docbranch: gh-pages
    # The name of the git remote to push to.
    docremote: origin
    # Use labels to decide for which releases an upload is needed.
    deploy_labels:
      - main
      - test

  build-py-source:
    # The task build-packages prepares packages for deployment.
    task: build-packages
    # Bash commands to make the packages.
    commands:
      - python setup.py sdist

  build-cmake-source:
    task: build-packages
    commands:
      - mkdir -p dist
      - cd dist; cmake .. -DCMAKE_BUILD_TYPE=release
      - cd dist; make sdist

  build-conda:
    task: build-packages
    conda_requirements:
      - conda-build
      - conda-verify
    commands:
      # CONDA_BUILD_PATH must be set because otherwise local dependencies
      # cannot be found when working in any other environment than base.
      # See https://github.com/conda/conda-build/issues/2592
      - >-
        CONDA_BUILD_PATH={config.conda.build_path}
        PROJECT_VERSION={config.git.tag_version}
        conda build tools/conda.recipe --override-channel --skip-existing
        --no-anaconda-upload

  deploy-pypi:
    # The task deploy uploads software packages to distribution servers.
    task: deploy
    conda_requirements:
      - twine
    deploy_vars:
      - TWINE_USERNAME
      - TWINE_PASSWORD
    # If a binary file is uploaded, this can be indicated here. This is useful
    # to let CI servers upload binary packages for different architectures.
    binary: false
    # Include a file with the sha256 sum when uploading, optional.
    include_sha256: true
    # Glob patterns to locate the "assets", i.e. the software packages to be
    # uploaded.
    asset_patterns:
      - '{package.path}/dist/{package.name}-{config.git.tag_version}.*'
    # List labels here for when the deployment is required. With main, only
    # stable releases are uploaded.
    deploy_labels:
      - main
    # Finally, the commands to perform the upload.
    commands:
      - twine upload {assets}

  deploy-github:
    task: deploy
    conda_requirements:
      - hub
    deploy_vars:
      - GITHUB_TOKEN
    binary: false
    include_sha256: true
    asset_patterns:
      - '{package.path}/dist/{package.name}-{config.git.tag_version}.*'
    deploy_labels:
      - main
    commands:
      - >-
        hub release create {hub_assets}
        -m "Automatic release of version {config.git.tag_version}"
        {config.git.tag_version}

  deploy-conda:
    task: deploy
    conda_requirements:
      - anaconda-client
    deploy_vars:
      - ANACONDA_API_TOKEN
    binary: true
    asset_patterns:
      - '{config.conda.build_path}/*/{package.name}-{config.git.tag_version}-*.*'
    deploy_labels:
      - main
      - test
      - dev
    commands:
      - 'anaconda -v upload --force -l {config.git.deploy_label} {assets}'
